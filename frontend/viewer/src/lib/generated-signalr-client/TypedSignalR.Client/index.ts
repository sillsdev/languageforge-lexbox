/* THIS (.ts) FILE IS GENERATED BY TypedSignalR.Client.TypeScript */
/* eslint-disable */
/* tslint:disable */

import type {
  IComplexFormComponent,
  IComplexFormType,
  IEntry,
  IExampleSentence,
  IMiniLcmFeatures,
  IMiniLcmJsInvokable,
  IPartOfSpeech,
  IQueryOptions,
  ISemanticDomain,
  ISense,
  IWritingSystem,
  IWritingSystems,
  WritingSystemType
} from '$lib/dotnet-types';

import {HubConnection} from '@microsoft/signalr';
import type {IFilterQueryOptions} from '$lib/dotnet-types/generated-types/MiniLcm/IFilterQueryOptions';
import type {ILexboxClient} from './Lexbox.ClientServer.Hubs';
import type {IPublication} from '$lib/dotnet-types/generated-types/MiniLcm/Models/IPublication';

// components

export type Disposable = {
  dispose(): void;
}

export type HubProxyFactory<T> = {
  createHubProxy(connection: HubConnection): T;
}

export type ReceiverRegister<T> = {
  register(connection: HubConnection, receiver: T): Disposable;
}

type ReceiverMethod = {
  methodName: string,
  method: (...args: any[]) => void
}

class ReceiverMethodSubscription implements Disposable {

  public constructor(
    private connection: HubConnection,
    private receiverMethod: ReceiverMethod[]) {
  }

  public readonly dispose = () => {
    for (const it of this.receiverMethod) {
      this.connection.off(it.methodName, it.method);
    }
  };
}

// API

export type HubProxyFactoryProvider = {
  (hubType: 'ILexboxApiHub'): HubProxyFactory<IMiniLcmJsInvokable>;
}

export const getHubProxyFactory = ((hubType: string) => {
  if (hubType === 'ILexboxApiHub') {
    return IMiniLcmJsInvokable_HubProxyFactory.Instance;
  }
}) as HubProxyFactoryProvider;

export type ReceiverRegisterProvider = {
  (receiverType: 'ILexboxClient'): ReceiverRegister<ILexboxClient>;
}

export const getReceiverRegister = ((receiverType: string) => {
  if (receiverType === 'ILexboxClient') {
    return ILexboxClient_Binder.Instance;
  }
}) as ReceiverRegisterProvider;

// HubProxy

class IMiniLcmJsInvokable_HubProxyFactory implements HubProxyFactory<IMiniLcmJsInvokable> {
  public static Instance = new IMiniLcmJsInvokable_HubProxyFactory();

  private constructor() {
  }

  public readonly createHubProxy = (connection: HubConnection): IMiniLcmJsInvokable => {
    return new IMiniLcmJsInvokable_HubProxy(connection);
  };
}

class IMiniLcmJsInvokable_HubProxy implements IMiniLcmJsInvokable {

    public constructor(private connection: HubConnection) {
    }

    public readonly getWritingSystems = async (): Promise<IWritingSystems> => {
        return await this.connection.invoke("GetWritingSystems");
    }

    public readonly createWritingSystem = async (type: WritingSystemType, writingSystem: IWritingSystem): Promise<IWritingSystem> => {
        return await this.connection.invoke("CreateWritingSystem", type, writingSystem);
    }

    public readonly getPartsOfSpeech = async (): Promise<IPartOfSpeech[]> => {
      return new Promise((resolve, reject) => {
        let partsOfSpeech: IPartOfSpeech[] = [];
        this.connection.stream<IPartOfSpeech>('GetPartsOfSpeech').subscribe({
          next(value: IPartOfSpeech) {
            partsOfSpeech.push(value);
          },
          error(err: any) {
            reject(err);
          },
          complete() {
            resolve(partsOfSpeech);
          }
        });
      });
    }

    public readonly getSemanticDomains = async (): Promise<ISemanticDomain[]> => {
      return new Promise((resolve, reject) => {
        let semanticDomains: ISemanticDomain[] = [];
        this.connection.stream<ISemanticDomain>('GetSemanticDomains').subscribe({
          next(value: ISemanticDomain) {
            semanticDomains.push(value);
          },
          error(err: any) {
            reject(err);
          },
          complete() {
            resolve(semanticDomains);
          }
        });
      });
    }

    public readonly getComplexFormTypes = async (): Promise<IComplexFormType[]> => {
      return new Promise((resolve, reject) => {
        let complexFormTypes: IComplexFormType[] = [];
        this.connection.stream<IComplexFormType>('GetComplexFormTypes').subscribe({
          next(value: IComplexFormType) {
            complexFormTypes.push(value);
          },
          error(err: any) {
            reject(err);
          },
          complete() {
            resolve(complexFormTypes);
          }
        });
      });
  }

    public readonly countEntries = async (query?: string, options?: IFilterQueryOptions): Promise<number> => {
      return await this.connection.invoke("CountEntries", options);
    }

    public readonly getEntries = async (options: IQueryOptions): Promise<IEntry[]> => {
        return await this.connection.invoke("GetEntries", options);
    }

  public readonly searchEntries = (query: string, options: IQueryOptions): Promise<IEntry[]> => {
    return new Promise((resolve, reject) => {
      let entries: IEntry[] = [];
      this.connection.stream<IEntry>('SearchEntries', query, options).subscribe({
        next(value: IEntry) {
          entries.push(value);
        },
        error(err: any) {
          reject(err);
        },
        complete() {
          resolve(entries);
        }
      });
    });
  };

    public readonly getEntry = async (id: string): Promise<IEntry> => {
        return await this.connection.invoke("GetEntry", id);
    }

    public readonly createEntry = async (entry: IEntry): Promise<IEntry> => {
        return await this.connection.invoke("CreateEntry", entry);
    }

    public readonly updateEntry = async (before: IEntry, after: IEntry): Promise<IEntry> => {
        return await this.connection.invoke("UpdateEntry", before, after);
    }

    public readonly deleteEntry = async (id: string): Promise<void> => {
        return await this.connection.invoke("DeleteEntry", id);
    }

    public readonly createSense = async (entryId: string, sense: ISense): Promise<ISense> => {
        return await this.connection.invoke("CreateSense", entryId, sense);
    }

    public readonly deleteSense = async (entryId: string, senseId: string): Promise<void> => {
        return await this.connection.invoke("DeleteSense", entryId, senseId);
    }

    public readonly createExampleSentence = async (entryId: string, senseId: string, exampleSentence: IExampleSentence): Promise<IExampleSentence> => {
        return await this.connection.invoke("CreateExampleSentence", entryId, senseId, exampleSentence);
    }

    public readonly deleteExampleSentence = async (entryId: string, senseId: string, exampleSentenceId: string): Promise<void> => {
        return await this.connection.invoke("DeleteExampleSentence", entryId, senseId, exampleSentenceId);
    }

    supportedFeatures(): Promise<IMiniLcmFeatures> {
      throw new Error('Method not implemented.');
    }

    getComplexFormType(id: string): Promise<IComplexFormType> {
      throw new Error('Method not implemented.');
    }

    getSense(entryId: string, id: string): Promise<ISense> {
      throw new Error('Method not implemented.');
    }

    getPartOfSpeech(id: string): Promise<IPartOfSpeech> {
      throw new Error('Method not implemented.');
    }

    getSemanticDomain(id: string): Promise<ISemanticDomain> {
      throw new Error('Method not implemented.');
    }

    getExampleSentence(entryId: string, senseId: string, id: string): Promise<IExampleSentence> {
      throw new Error('Method not implemented.');
    }

    updateWritingSystem(before: IWritingSystem, after: IWritingSystem): Promise<IWritingSystem> {
      throw new Error('Method not implemented.');
    }

    createPartOfSpeech(partOfSpeech: IPartOfSpeech): Promise<IPartOfSpeech> {
      throw new Error('Method not implemented.');
    }

    updatePartOfSpeech(before: IPartOfSpeech, after: IPartOfSpeech): Promise<IPartOfSpeech> {
      throw new Error('Method not implemented.');
    }

    deletePartOfSpeech(id: string): Promise<void> {
      throw new Error('Method not implemented.');
    }

    createSemanticDomain(semanticDomain: ISemanticDomain): Promise<ISemanticDomain> {
      throw new Error('Method not implemented.');
    }

    updateSemanticDomain(before: ISemanticDomain, after: ISemanticDomain): Promise<ISemanticDomain> {
      throw new Error('Method not implemented.');
    }

    deleteSemanticDomain(id: string): Promise<void> {
      throw new Error('Method not implemented.');
    }

    createComplexFormType(complexFormType: IComplexFormType): Promise<IComplexFormType> {
      throw new Error('Method not implemented.');
    }

    updateComplexFormType(before: IComplexFormType, after: IComplexFormType): Promise<IComplexFormType> {
      throw new Error('Method not implemented.');
    }

    deleteComplexFormType(id: string): Promise<void> {
      throw new Error('Method not implemented.');
    }

    createComplexFormComponent(complexFormComponent: IComplexFormComponent): Promise<IComplexFormComponent> {
      throw new Error('Method not implemented.');
    }

    deleteComplexFormComponent(complexFormComponent: IComplexFormComponent): Promise<void> {
      throw new Error('Method not implemented.');
    }

    addComplexFormType(entryId: string, complexFormTypeId: string): Promise<void> {
      throw new Error('Method not implemented.');
    }

    removeComplexFormType(entryId: string, complexFormTypeId: string): Promise<void> {
      throw new Error('Method not implemented.');
    }

    updateSense(entryId: string, before: ISense, after: ISense): Promise<ISense> {
      throw new Error('Method not implemented.');
    }

    addSemanticDomainToSense(senseId: string, semanticDomain: ISemanticDomain): Promise<void> {
      throw new Error('Method not implemented.');
    }

    removeSemanticDomainFromSense(senseId: string, semanticDomainId: string): Promise<void> {
      throw new Error('Method not implemented.');
    }

    updateExampleSentence(entryId: string, senseId: string, before: IExampleSentence, after: IExampleSentence): Promise<IExampleSentence> {
      throw new Error('Method not implemented.');
    }

  getPublications(): Promise<IPublication[]> {
    throw new Error('Method not implemented.');
  }

    dispose(): Promise<void> {
      throw new Error('Method not implemented.');
    }
}


// Receiver

class ILexboxClient_Binder implements ReceiverRegister<ILexboxClient> {

    public static Instance = new ILexboxClient_Binder();

    private constructor() {
    }

    public readonly register = (connection: HubConnection, receiver: ILexboxClient): Disposable => {

        const __onEntryUpdated = (...args: Parameters<ILexboxClient['OnEntryUpdated']>) => receiver.OnEntryUpdated(...args);
        const __onProjectClosed = (...args: Parameters<ILexboxClient['OnProjectClosed']>) => receiver.OnProjectClosed(...args);

        connection.on("OnEntryUpdated", __onEntryUpdated);
        connection.on("OnProjectClosed", __onProjectClosed);

        const methodList: ReceiverMethod[] = [
            { methodName: "OnEntryUpdated", method: __onEntryUpdated },
            { methodName: "OnProjectClosed", method: __onProjectClosed },
        ]

        return new ReceiverMethodSubscription(connection, methodList);
    }
}

